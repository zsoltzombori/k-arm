import numpy as np
from arm import ArmLayer
from vis import *
from diff_vis import *
from model import *
import data
import argparse
import re
import os.path
import sys
sys.setrecursionlimit(2**20)

dict_size_list = (400, 400, 400, 400, 400)

parser = argparse.ArgumentParser(description="Sparse image encoding using several layers of k-arm.")
parser.add_argument('--iteration', dest="iteration", type=int, default=6, help="Number of iterations in k-arm approximation")
parser.add_argument('--threshold', dest="threshold", type=float, default=0.5, help="Sparsity coefficient")
parser.add_argument('--epoch', dest="epoch", type=int, default=10, help="Number of epochs")
parser.add_argument('--lr', dest="lr", type=float, default=0.001, help="learning rate")
parser.add_argument('--trainSize', dest="trainSize", type=int, default=5000, help="Training set size")
parser.add_argument('--testSize', dest="testSize", type=int, default=1000, help="Test set size")
parser.add_argument('--batch', dest="batchSize", type=int, default=16, help="Batch size")
parser.add_argument('--resultFile', dest="resultFile", default=None, help="File to write results")
parser.add_argument('--layers', dest="layers", type=int, default=1, help="Number of stacked arm layers")
args = parser.parse_args()
iteration = args.iteration
threshold = args.threshold
nb_epoch = args.epoch
trainSize = args.trainSize
testSize = args.testSize 
layers = args.layers
nb_epoch = args.epoch * layers
batchSize = args.batchSize
lr = args.lr
resultFile = args.resultFile


(X_train, Y_train), (X_test, Y_test), datagen, test_datagen, nb_classes = data.load_mnist()
X_train = X_train[:trainSize]
X_test = X_test[:testSize]
vis(X_test * 255, "orig.png")
nb_features = np.prod(X_test.shape[1:])

model = build_encode_decode_layers(input_shape=X_test.shape, iteration=iteration, threshold=threshold, dict_size_list=dict_size_list, lr=lr, layers=layers)

#fit the model on the batches generated by datagen.flow()
model.fit_generator(datagen.flow(X_train, X_train, batch_size=batchSize, shuffle=True),
                        samples_per_epoch=X_train.shape[0],
                        nb_epoch=nb_epoch,
                        validation_data=test_datagen.flow(X_test, X_test, batch_size=batchSize),
                        nb_val_samples=X_test.shape[0]
                        )


y_fun = K.function([model.layers[0].input], [model.layers[1].output])
Y_learned = y_fun([X_test])[0]
X_prime_learned = model.predict_on_batch(X_test)

nonzero = np.apply_along_axis(np.count_nonzero, axis=1, arr=Y_learned)
nonzeroHist = np.histogram(nonzero, bins=20)
print nonzeroHist[0]
print nonzeroHist[1]

nonzeroW = np.apply_along_axis(np.count_nonzero, axis=0, arr=Y_learned)
nonzeroWHist = np.histogram(nonzeroW, bins=10)
print nonzeroWHist[0]
print nonzeroWHist[1]

nonzeroInt = int(np.average(nonzero))
print "Average number of nonzero elements in the code: ", nonzeroInt
reconsError = np.sum(np.square(X_prime_learned-X_test)) / testSize / nb_features
print "Reconstruction error: ", reconsError
sparsity_loss = threshold * np.sum(np.abs(Y_learned)) / testSize / nb_features
total_loss = reconsError + sparsity_loss
print "Total loss: ", total_loss

suffix = "layers_{}it{}_th{}_lr{}_train{}_test{}_batch{}_epoch{}_loss{:.3f}.png".format(layers,iteration,threshold,lr,trainSize,testSize,batchSize,nb_epoch,total_loss)

vis(X_prime_learned * 255, "stacked/lista_" + suffix)
diff_vis(X_test[:400],X_prime_learned[:400],28,28,20,20,"stacked/lista_diff_" + suffix)

# W_learned = model.layers[1].get_weights()[0]
# W_scaled = W_learned - np.min(W_learned)
# W_scaled /= np.max(W_scaled)
# W_scaled *= 255
# vis(W_scaled, "stacked/lista_dict_" + suffix, n=int(np.sqrt(dict_size)))

# if resultFile was provided then add new line to result file
if resultFile is not None:
    if os.path.exists(resultFile):
        with open(resultFile, "a") as file:
            file.write("{};{};{};{};{};{};{}\n".format(layers,iteration,threshold,reconsError,sparsity_loss,nonzeroInt,total_loss))
    else:
        with open(resultFile, "w") as file:
            file.write("Layers;Iteration;Threshold,ReconsError;SparsityLoss;Nonzero;Loss\n")
            file.write("{};{};{};{};{};{};{}\n".format(layers,iteration,threshold,reconsError,sparsity_loss,nonzeroInt,total_loss))

